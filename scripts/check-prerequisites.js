#!/usr/bin/env node

/**
 * Script de Verifica√ß√£o de Pr√©-requisitos
 * Chat AI Central - Migra√ß√£o Supabase para PostgreSQL
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');

const execAsync = util.promisify(exec);

// Cores para output
const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

class PrerequisiteChecker {
    constructor() {
        this.checks = [];
        this.warnings = [];
        this.errors = [];
        this.info = [];
    }

    log(message, color = 'reset') {
        console.log(`${colors[color]}${message}${colors.reset}`);
    }

    success(message) {
        this.log(`‚úÖ ${message}`, 'green');
        this.checks.push({ type: 'success', message });
    }

    warning(message) {
        this.log(`‚ö†Ô∏è  ${message}`, 'yellow');
        this.warnings.push(message);
    }

    error(message) {
        this.log(`‚ùå ${message}`, 'red');
        this.errors.push(message);
    }

    info(message) {
        this.log(`‚ÑπÔ∏è  ${message}`, 'blue');
        this.info.push(message);
    }

    async checkNodeVersion() {
        try {
            const { stdout } = await execAsync('node --version');
            const version = stdout.trim();
            const majorVersion = parseInt(version.replace('v', '').split('.')[0]);
            
            if (majorVersion >= 16) {
                this.success(`Node.js ${version} (compat√≠vel)`);
            } else {
                this.error(`Node.js ${version} (requer vers√£o 16+)`);
            }
        } catch (error) {
            this.error('Node.js n√£o encontrado');
        }
    }

    async checkNpmVersion() {
        try {
            const { stdout } = await execAsync('npm --version');
            const version = stdout.trim();
            this.success(`npm ${version}`);
        } catch (error) {
            this.error('npm n√£o encontrado');
        }
    }

    async checkPostgreSQL() {
        try {
            const { stdout } = await execAsync('psql --version');
            const version = stdout.trim();
            this.success(`PostgreSQL cliente: ${version}`);
            
            // Verificar se o servidor est√° rodando
            try {
                await execAsync('systemctl is-active postgresql');
                this.success('Servi√ßo PostgreSQL ativo');
            } catch {
                this.warning('Servi√ßo PostgreSQL n√£o est√° ativo');
            }
        } catch (error) {
            this.error('PostgreSQL n√£o encontrado - execute setup-postgresql.sh');
        }
    }

    checkProjectStructure() {
        const requiredFiles = [
            'package.json',
            'server.js',
            '.env',
            'database/postgresql.js',
            'database/supabase.js'
        ];

        const requiredDirs = [
            'client',
            'database',
            'scripts'
        ];

        requiredFiles.forEach(file => {
            if (fs.existsSync(file)) {
                this.success(`Arquivo encontrado: ${file}`);
            } else {
                this.error(`Arquivo n√£o encontrado: ${file}`);
            }
        });

        requiredDirs.forEach(dir => {
            if (fs.existsSync(dir) && fs.statSync(dir).isDirectory()) {
                this.success(`Diret√≥rio encontrado: ${dir}`);
            } else {
                this.error(`Diret√≥rio n√£o encontrado: ${dir}`);
            }
        });
    }

    checkEnvironmentVariables() {
        if (!fs.existsSync('.env')) {
            this.error('Arquivo .env n√£o encontrado');
            return;
        }

        const envContent = fs.readFileSync('.env', 'utf8');
        const envVars = {};
        
        envContent.split('\n').forEach(line => {
            const [key, value] = line.split('=');
            if (key && value) {
                envVars[key.trim()] = value.trim();
            }
        });

        // Vari√°veis do Supabase
        const supabaseVars = ['SUPABASE_URL', 'SUPABASE_ANON_KEY'];
        supabaseVars.forEach(varName => {
            if (envVars[varName]) {
                this.success(`Vari√°vel Supabase: ${varName}`);
            } else {
                this.warning(`Vari√°vel Supabase n√£o encontrada: ${varName}`);
            }
        });

        // Vari√°veis do PostgreSQL
        const pgVars = ['PG_HOST', 'PG_PORT', 'PG_DATABASE', 'PG_USER', 'PG_PASSWORD'];
        let pgConfigured = 0;
        
        pgVars.forEach(varName => {
            if (envVars[varName]) {
                this.success(`Vari√°vel PostgreSQL: ${varName}`);
                pgConfigured++;
            } else {
                this.warning(`Vari√°vel PostgreSQL n√£o encontrada: ${varName}`);
            }
        });

        if (pgConfigured === 0) {
            this.error('Nenhuma configura√ß√£o PostgreSQL encontrada no .env');
        } else if (pgConfigured < pgVars.length) {
            this.warning('Configura√ß√£o PostgreSQL incompleta no .env');
        }
    }

    async checkDiskSpace() {
        try {
            const { stdout } = await execAsync('df -h .');
            const lines = stdout.trim().split('\n');
            const diskInfo = lines[1].split(/\s+/);
            const available = diskInfo[3];
            const usage = diskInfo[4];
            
            this.info(`Espa√ßo dispon√≠vel: ${available} (uso: ${usage})`);
            
            // Verificar se h√° pelo menos 1GB dispon√≠vel
            const availableGB = parseFloat(available.replace('G', ''));
            if (availableGB < 1) {
                this.warning('Pouco espa√ßo em disco dispon√≠vel (< 1GB)');
            }
        } catch (error) {
            this.warning('N√£o foi poss√≠vel verificar espa√ßo em disco');
        }
    }

    async checkMemory() {
        try {
            const { stdout } = await execAsync('free -h');
            const lines = stdout.trim().split('\n');
            const memInfo = lines[1].split(/\s+/);
            const total = memInfo[1];
            const available = memInfo[6] || memInfo[3];
            
            this.info(`Mem√≥ria total: ${total}, dispon√≠vel: ${available}`);
            
            // Verificar se h√° pelo menos 512MB dispon√≠vel
            const availableMB = parseFloat(available.replace('G', '')) * 1024 || parseFloat(available.replace('M', ''));
            if (availableMB < 512) {
                this.warning('Pouca mem√≥ria dispon√≠vel (< 512MB)');
            }
        } catch (error) {
            this.warning('N√£o foi poss√≠vel verificar mem√≥ria');
        }
    }

    checkPackageJson() {
        if (!fs.existsSync('package.json')) {
            this.error('package.json n√£o encontrado');
            return;
        }

        try {
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            
            // Verificar depend√™ncias importantes
            const requiredDeps = {
                'express': 'Servidor web',
                'socket.io': 'WebSocket',
                'whatsapp-web.js': 'WhatsApp API',
                'pg': 'PostgreSQL driver'
            };

            Object.entries(requiredDeps).forEach(([dep, description]) => {
                if (packageJson.dependencies && packageJson.dependencies[dep]) {
                    this.success(`Depend√™ncia: ${dep} (${description})`);
                } else {
                    this.warning(`Depend√™ncia n√£o encontrada: ${dep} (${description})`);
                }
            });

        } catch (error) {
            this.error('Erro ao ler package.json');
        }
    }

    async checkDatabaseConnection() {
        // Verificar conex√£o com Supabase
        try {
            const supabaseModule = require('../database/supabase.js');
            this.success('M√≥dulo Supabase carregado');
        } catch (error) {
            this.error('Erro ao carregar m√≥dulo Supabase');
        }

        // Verificar conex√£o com PostgreSQL
        try {
            const postgresModule = require('../database/postgresql.js');
            this.success('M√≥dulo PostgreSQL carregado');
        } catch (error) {
            this.error('Erro ao carregar m√≥dulo PostgreSQL');
        }
    }

    async checkPorts() {
        const ports = [3000, 5432]; // Express e PostgreSQL
        
        for (const port of ports) {
            try {
                const { stdout } = await execAsync(`netstat -tlnp | grep :${port}`);
                if (stdout.trim()) {
                    this.info(`Porta ${port} em uso`);
                } else {
                    this.success(`Porta ${port} dispon√≠vel`);
                }
            } catch (error) {
                this.success(`Porta ${port} dispon√≠vel`);
            }
        }
    }

    generateReport() {
        this.log('\n' + '='.repeat(60), 'cyan');
        this.log('üìã RELAT√ìRIO DE PR√â-REQUISITOS', 'cyan');
        this.log('='.repeat(60), 'cyan');

        this.log(`\n‚úÖ Verifica√ß√µes bem-sucedidas: ${this.checks.length}`, 'green');
        this.log(`‚ö†Ô∏è  Avisos: ${this.warnings.length}`, 'yellow');
        this.log(`‚ùå Erros: ${this.errors.length}`, 'red');

        if (this.warnings.length > 0) {
            this.log('\n‚ö†Ô∏è  AVISOS:', 'yellow');
            this.warnings.forEach(warning => {
                this.log(`   ‚Ä¢ ${warning}`, 'yellow');
            });
        }

        if (this.errors.length > 0) {
            this.log('\n‚ùå ERROS:', 'red');
            this.errors.forEach(error => {
                this.log(`   ‚Ä¢ ${error}`, 'red');
            });
        }

        this.log('\nüìä RECOMENDA√á√ïES:', 'blue');
        
        if (this.errors.length === 0) {
            this.log('   ‚úÖ Sistema pronto para migra√ß√£o!', 'green');
            this.log('   üìù Pr√≥ximos passos:', 'blue');
            this.log('      1. Execute: sudo ./scripts/setup-postgresql.sh', 'blue');
            this.log('      2. Configure vari√°veis PostgreSQL no .env', 'blue');
            this.log('      3. Execute: node scripts/migrate-supabase-to-postgres.js', 'blue');
        } else {
            this.log('   ‚ùå Corrija os erros antes de prosseguir', 'red');
            this.log('   üìñ Consulte a documenta√ß√£o para mais detalhes', 'blue');
        }

        this.log('\n' + '='.repeat(60), 'cyan');
        
        return this.errors.length === 0;
    }

    async runAllChecks() {
        this.log('üîç Verificando pr√©-requisitos para migra√ß√£o...\n', 'cyan');

        this.log('üì¶ Verificando ambiente Node.js...', 'blue');
        await this.checkNodeVersion();
        await this.checkNpmVersion();

        this.log('\nüêò Verificando PostgreSQL...', 'blue');
        await this.checkPostgreSQL();

        this.log('\nüìÅ Verificando estrutura do projeto...', 'blue');
        this.checkProjectStructure();

        this.log('\nüîß Verificando configura√ß√µes...', 'blue');
        this.checkEnvironmentVariables();
        this.checkPackageJson();

        this.log('\nüíæ Verificando recursos do sistema...', 'blue');
        await this.checkDiskSpace();
        await this.checkMemory();

        this.log('\nüåê Verificando conectividade...', 'blue');
        await this.checkDatabaseConnection();
        await this.checkPorts();

        return this.generateReport();
    }
}

// Executar verifica√ß√µes
async function main() {
    const checker = new PrerequisiteChecker();
    
    try {
        const success = await checker.runAllChecks();
        process.exit(success ? 0 : 1);
    } catch (error) {
        console.error('‚ùå Erro durante verifica√ß√£o:', error.message);
        process.exit(1);
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    main();
}

module.exports = PrerequisiteChecker;